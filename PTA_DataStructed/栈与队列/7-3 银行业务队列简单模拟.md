# 银行业务队列简单模拟

设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。

**输入格式:**
输入为一行正整数，其中第1个数字N(≤1000)为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。

**输出格式:**
按业务处理完成的顺序输出顾客的编号。数字间以空格分隔，但最后一个编号后不能有多余的空格。

输入样例:
```C
8 2 1 3 9 4 11 13 15
```
输出样例:
```C
1 3 2 9 11 4 13 15
```
## 我的解题思路：
设计两个队、按照规定的次序访问。设计代码如下


```C
#include<iostream>
#include<queue>

using namespace std;

int main()
{
	queue<int> qa;
	queue<int> qb;
	int num;
	cin >> num;
	for (int j, i = 0; i < num; ++i)
	{
		cin >> j;
		if (j % 2 == 1)
		{
			qa.push(j);
		}
		else
		{
			qb.push(j);
		}
	}
	int temp = 1;//额外设计一个计数器，当最后一个元素输出时不加空格
	while (!qa.empty() || !qb.empty())
	{
		for (int i = 0; i < 2; ++i)
		{
			if (!qa.empty())
			{
				if (temp != num)
				{
					cout << qa.front() << " ";
					qa.pop();
					temp++;
				}
				else
				{
					cout << qa.front();
					qa.pop();
					temp++;
				}
			}
		}
		
		if (!qb.empty())
		{
			if (temp != num)
			{
				cout << qb.front() << " ";
				qb.pop();
				temp++;
			}
			else
			{
				cout << qb.front();
				qb.pop();
				
			}
		}
	}
	return 0;
}
```
